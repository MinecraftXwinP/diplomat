package diplomat

import (
	"bytes"
	"errors"
	"fmt"
	"html/template"
	"log"
)

type messengerRegistry map[string]MessengerFunc

var messengerRegistryInstance messengerRegistry

var JsMessengerTemplate *template.Template

func init() {
	var err error
	JsMessengerTemplate, err = template.New("jsMessengerTemplate").Parse(`// DO NOT EDIT. generated by diplomat (https://github.com/MinecraftXwinP/diplomat).
export default {
{{ range $k,$v := . -}}
    "{{$k}}": "{{$v}}",
{{- end }}
}
`)
	if err != nil {
		log.Fatal(err)
	}

	messengerRegistryInstance = make(messengerRegistry, 1)

	RegisterMessenger("js", javascriptMessengerFunc)
}

func RegisterMessenger(messengerType string, f MessengerFunc) {
	messengerRegistryInstance[messengerType] = f
}

type MessengerFunc func(languages map[string]YAMLMap, options YAMLOption, buildspace IBuildSpace) error

type MessengerConfig struct {
	Type    string
	Options YAMLOption
}

func resolveTemplate(input string, params interface{}) (string, error) {
	t, err := template.New("temp").Parse(input)
	if err != nil {
		return "", err
	}
	return execTemplateString(t, params)
}

func execTemplateString(t *template.Template, data interface{}) (string, error) {
	var buffer bytes.Buffer
	err := t.Execute(&buffer, data)
	if err != nil {
		return "", err
	}
	return string(buffer.Bytes()), nil
}

func implodeStringSlice(ss []string, glue string) string {
	var out string
	for i, s := range ss {
		if i == len(ss)-1 {
			out += s
			continue
		}
		out += fmt.Sprintf("%s.", s)
	}
	return out
}

func javascriptMessengerFunc(languages map[string]YAMLMap, options YAMLOption, bs IBuildSpace) error {
	filenameTemplate, err := options.Get("filename")
	if err != nil {
		return errors.New("missing filename option")
	}
	for language, translations := range languages {
		name, err := resolveTemplate(
			filenameTemplate.(string),
			struct {
				Lang string
			}{
				Lang: language,
			},
		)
		if err != nil {
			return fmt.Errorf("error on resolving filename: %s", err)
		}
		f, err := bs.Create(name)
		if err != nil {
			return err
		}
		defer f.Close()
		keys := translations.GetKeys()
		aMap := make(map[string]string, len(keys))
		for _, k := range keys {
			v, _ := translations.GetKey(k...)
			aMap[implodeStringSlice(k[:len(k)-1], ".")] = v.(string)
		}
		err = JsMessengerTemplate.Execute(f, aMap)
		f.Close()
		if err != nil {
			return err
		}
	}
	return nil
}
